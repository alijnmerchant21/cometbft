# ADR 103: Local state sync support

## Changelog

- 2022-10-31: Initial Draft (@cmwaters)
- 2023-04-20: ADR renumbered, revised, ported to CometBFT repo (@adizere)

## Status

Accepted | Rejected | Deprecated | Superseded by

## Context

### Problem & History

In CometBFT v0.34, synchronizing a fresh node with the rest of the network
relies on a protocol that fetches snapshots from the other peers in the network,
i.e., [state sync][polka-ss]. Some disadvantages of this approach are that it is
fragile (because peer snapshots might not be immediately available) and
bandwidth-intensive. This problem is particularly interesting because CometBFT
node operators employ state syncing of new nodes frequently.

Alternatives to network-based state sync exist. For instance, using a local
snapshot, which may have been generated by the node itself or copied from a
trusted source, state synchronization could avoid large transfers from remote
peers. Such an alternative [has been explored in ADR 083][adr083] and PR
[#9541][9541] as part of Tendermint Core, but it did not get a chance to
materialize into a solution that was adopted.

### Technical Context

Whenever CometBFT begins, it initiates a [handshake][handshake] with the
application via `Info` to gauge version compatibility and receive the last
height and app hash of the application. CometBFT then begins a replay protocol
which aims to sync the heights of CometBFT's state and block store with the
current height of the application.

When initially designed, one invariant was that the applications current height
should never exceed CometBFT's height. The protocol would error and the node
would shut down if this were to happen. It seemed appropriate at the time that
CometBFT (which would provide blocks either through block sync or consensus)
would always be ahead of the application. However, in light of state sync and
other protocols for bootstrapping an application to a particular height, this
invariant is no longer necessary.

## Decision

Allow applications to start with a bootstrapped state alongside an empty
CometBFT instance using a subsystem of the state sync protocol.

## Detailed Design

CometBFT will perform a protocol to bootstrap to the height of the application
under the following circumstances:

- The returned application height is greater than CometBFT's blockstore height, and
- CometBFT's block store has a height of 0 (i.e. it's empty and we're not
  overriding an existing instance; this check may be relaxed in the future), and
- State sync is enabled and the config is valid (i.e it contains at least two
  RPC endpoints and a trusted header and hash).

The bootstrap protocol will run directly after the handshake. It (currently)
does not require the p2p layer and will work by updating the `StateStore` and
`BlockStore`. It should be performed instead of statesync, moving to either
blocksync or consensus once completed.

The protocol mainly wraps around the `StateProvider` which is derived from the
`StateSyncConfig` and currently uses the RPC layer and light client to produce a
`State` and `Commit` (to be passed to consensus for the next height).

The pseudocode for the bootstrap protocol is as follows:

```go
func Bootstrap(sp StateProvider, appHeight int64, appHash []byte, bs BlockStore,
        ss StateStore) (*State, error) { state, err := sp.State(appHeight)

    if !bytes.Equal(state.AppHash, appHash) {
        return errors.New("application state hash mismatches block's app hash")
    }

    lastCommit, err := sp.Commit(appHeight)

    err = ss.Bootstrap(state)

    err = bs.SaveSeenCommit(lastCommit)

    return state, err
}
```

## Consequences

### Positive

- This is a non-breaking change
- Applications can now use their own state syncing protocols. This is especially
  useful when the saved snapshot is already from a trusted node.
- CometBFT will still verify application state in the event that the out of band
  state does not match the hash of the respective block on chain

### Negative

### Neutral

- Additional complexity: Users will need to have state sync correctly configured
  and enabled to take advantage of this feature.

## References

- Initial issue on the Tendermint Core repo:
  [4642](https://github.com/tendermint/tendermint/issues/4642)
- Initial ADR 083 on the Tendermint Core repo, which served as a basis for the
  present ADR [ADR 083 Supporting out of band state sync #9651][9651]

<!-- Links -->

[handshake]: https://github.com/cometbft/cometbft/blob/2bb39a365ac1c9294f419a860563bed3c534ef65/node/node.go#L316
[9651]: https://github.com/tendermint/tendermint/pull/9651
[9541]: https://github.com/tendermint/tendermint/pull/9541
[adr083]: https://github.com/tendermint/tendermint/blob/cal/local-sync-adr/docs/architecture/adr-083-out-of-band-sync.md
[polka-ss]: https://www.polkachu.com/state_sync/cosmos
